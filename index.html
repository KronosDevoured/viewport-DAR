<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>DAR Rings — fixed non-DAR (free spin), DAR 1:1 spin</title>
<style>
  html,body{margin:0;height:100%;background:#0f1116;color:#e7ecf3;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr}
  header{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:.6rem .8rem;padding:.6rem .8rem;background:#12161d;border-bottom:1px solid #1f2530}
  .sl{display:flex;flex-wrap:wrap;gap:1rem;flex:1 1 980px;min-width:0}
  .control{display:flex;flex-direction:column;gap:.25rem;flex:1 1 220px;min-width:180px}
  .control label{font-size:.9rem;opacity:.9}
  .control input[type=number]{background:#0f141c;border:1px solid #2a3342;color:#e7ecf3;border-radius:8px;padding:.35rem .5rem;font-size:.95rem}
  .control input[type=range]{flex:1;min-width:80px}
  .tag{margin-top:.1rem;align-self:flex-start;white-space:nowrap;font-size:.82rem;opacity:.9}
  .actions{display:flex;gap:.5rem;flex:0 0 auto}
  button{border:1px solid #2a3342;background:#151b24;color:#e7ecf3;border-radius:10px;padding:.35rem .6rem;font-weight:600}
  .toggle{border:1px solid #2a3342;background:#0f141c;border-radius:10px;display:flex;overflow:hidden}
  .toggle button{border:0;padding:.35rem .6rem}
  .toggle button[aria-pressed="true"]{background:#1a2230}
  #scene{position:relative}
  #hud{position:absolute;inset:auto 0 .8rem 0;display:flex;justify-content:center;gap:.8rem;pointer-events:none}
  .hint{pointer-events:auto;background:#0f141c;border:1px solid #2a3342;padding:.35rem .55rem;border-radius:10px;font-size:.85rem}
  #stickWrap{pointer-events:auto;display:flex;align-items:center;gap:.5rem;background:#0f141c;border:1px solid #2a3342;border-radius:12px;padding:.4rem .6rem}
  #stick{width:120px;height:120px;display:block}
  .legend{display:flex;flex-wrap:wrap;gap:.3rem .6rem;font-size:.8rem;opacity:.9}
  .chip{display:inline-flex;align-items:center;gap:.35rem;background:#0f141c;border:1px solid #2a3342;border-radius:999px;padding:.18rem .5rem}
  .dot{width:.65rem;height:.65rem;border-radius:50%}
  .up{background:#ff5c5c}.down{background:#53d769}.right{background:#4c8dff}.left{background:#ffd166}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="sl">
      <div class="control">
        <label for="morph">Morph (stick)</label>
        <input id="morph" type="range" min="0" max="1" step="0.001" value="0" disabled>
        <span id="morphTag" class="tag">0.000</span>
      </div>
      <div class="control">
        <label for="alpha">End Cone</label>
        <input id="alpha" type="range" min="5" max="60" step="1" value="30">
        <span id="alphaTag" class="tag">30°</span>
      </div>
      <div class="control">
        <label for="carSize">Car Size</label>
        <input id="carSize" type="range" min="0.005" max="0.08" step="0.001" value="0.010">
        <span id="carSizeTag" class="tag">0.010</span>
      </div>
      <div class="control">
        <label for="rodHeight">Rod Height (±100)</label>
        <input id="rodHeight" type="number" min="-100" max="100" step="0.001" value="-0.200">
        <span id="rodHeightTag" class="tag">-0.200</span>
      </div>
      <div class="control">
        <label for="carHeight">Mesh Height (offset, ±100)</label>
        <input id="carHeight" type="number" min="-100" max="100" step="0.001" value="-0.200">
        <span id="carHeightTag" class="tag">-0.200</span>
      </div>
    </div>
    <div class="actions">
      <div class="toggle" role="toolbar" aria-label="DAR mode">
        <button id="arl" type="button" aria-pressed="false" title="ARL">ARL</button>
        <button id="arr" type="button" aria-pressed="false" title="ARR">ARR</button>
      </div>
      <button id="reset" type="button">Reset View</button>
    </div>
  </header>

  <div id="scene"></div>

  <div id="hud">
    <div id="stickWrap">
      <canvas id="stick" width="120" height="120"></canvas>
      <div class="legend">
        <span class="chip"><span class="dot up"></span>Up</span>
        <span class="chip"><span class="dot down"></span>Down</span>
        <span class="chip"><span class="dot right"></span>Right</span>
        <span class="chip"><span class="dot left"></span>Left</span>
      </div>
    </div>
    <div class="hint">DAR OFF: continuous free spin, no world-up, no flips. DAR ON: car spin = circle progress 1:1. Deadzone snaps to start.</div>
  </div>
</div>

<script type="module">
import * as THREE from "https://esm.sh/three@0.155.0";
import { OrbitControls } from "https://esm.sh/three@0.155.0/examples/jsm/controls/OrbitControls.js";
import { GLTFLoader } from "https://esm.sh/three@0.155.0/examples/jsm/loaders/GLTFLoader.js";

/* renderer */
const host=document.getElementById('scene');
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth,innerHeight-document.querySelector('header').offsetHeight);
renderer.outputColorSpace=THREE.SRGBColorSpace;
host.appendChild(renderer.domElement);

/* scene */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x0f1116);
const camera=new THREE.PerspectiveCamera(50,renderer.domElement.width/renderer.domElement.height,0.01,100);
camera.position.set(2.3,1.6,2.5);
const controls=new OrbitControls(camera,renderer.domElement); controls.enableDamping=true;

scene.add(new THREE.HemisphereLight(0xd9e6ff,0x17202c,0.9));
const dl=new THREE.DirectionalLight(0xffffff,0.6); dl.position.set(2,3,1); scene.add(dl);

/* refs */
scene.add(new THREE.Mesh(new THREE.SphereGeometry(1,64,48),
  new THREE.MeshPhongMaterial({color:0x0e141d,specular:0x111111,shininess:10,transparent:true,opacity:0.25})
));
const grid=new THREE.GridHelper(8,16,0x2a3342,0x1d2430); grid.position.y=-1.25; scene.add(grid);
scene.add(new THREE.AxesHelper(1.25));

/* pivot marker */
const pivot=new THREE.Mesh(new THREE.SphereGeometry(0.03,16,12),new THREE.MeshBasicMaterial({color:0xff4444}));
pivot.position.set(0,0,1); scene.add(pivot);

/* constants */
const RING_SEGS=256, N=RING_SEGS+1, EPS=1e-6;
const DEADZONE=0.08;

/* great circles */
const baseMats=[
  new THREE.LineBasicMaterial({color:0x6b7380, transparent:true, opacity:0.45, depthTest:false}),
  new THREE.LineBasicMaterial({color:0x6b7380, transparent:true, opacity:0.45, depthTest:false}),
  new THREE.LineBasicMaterial({color:0x3c4452, transparent:true, opacity:0.45, depthTest:false}),
  new THREE.LineBasicMaterial({color:0x3c4452, transparent:true, opacity:0.45, depthTest:false})
];
const axesDir=[ new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0), new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0) ];
function framePerp(a){ const tmp=Math.abs(a.z)<0.9?new THREE.Vector3(0,0,1):new THREE.Vector3(0,1,0); const u=tmp.clone().cross(a).normalize(); const v=a.clone().cross(u).normalize(); return {u,v}; }
const rings=[];
for(let i=0;i<4;i++){
  const g=new THREE.BufferGeometry();
  g.setAttribute('position',new THREE.BufferAttribute(new Float32Array(3*N),3));
  const line=new THREE.Line(g,baseMats[i]); scene.add(line);
  rings.push({line,cur:g.attributes.position.array,axis:axesDir[i].clone()});
}
function greatCirclePerAxis(axis,arr){
  const {u,v}=framePerp(axis); const R=1.003;
  for(let k=0;k<=RING_SEGS;k++){
    const t=(k/RING_SEGS)*Math.PI*2;
    const p=u.clone().multiplyScalar(Math.cos(t)*R).add(v.clone().multiplyScalar(Math.sin(t)*R));
    const i3=3*k; arr[i3]=p.x; arr[i3+1]=p.y; arr[i3+2]=p.z;
  }
}
function drawGreatCircles(){ for(const r of rings){ greatCirclePerAxis(r.axis,r.cur); r.line.geometry.attributes.position.needsUpdate=true; } }
function setGreatOpacity(darActive){ for(const r of rings){ r.line.material.opacity = darActive ? 0.30 : 0.45; } }

/* DAR preview rings */
const darColors=[0xff5c5c,0x53d769,0x4c8dff,0xffd166]; // Up,Down,Right,Left
const darRings=[];
for(let i=0;i<4;i++){
  const g=new THREE.BufferGeometry();
  g.setAttribute('position',new THREE.BufferAttribute(new Float32Array(3*N),3));
  const line=new THREE.Line(g,new THREE.LineBasicMaterial({color:darColors[i],opacity:0.95,transparent:true,depthTest:false}));
  line.visible=false; scene.add(line);
  darRings.push({line,buf:g.attributes.position.array});
}
function circleFrame(alpha,phi){
  const ca=Math.cos(alpha), sa=Math.sin(alpha);
  const c=new THREE.Vector3(Math.sin(alpha)*Math.cos(phi),Math.sin(alpha)*Math.sin(phi),Math.cos(alpha)).normalize();
  const tmp=Math.abs(c.z)<0.9?new THREE.Vector3(0,0,1):new THREE.Vector3(0,1,0);
  const u=tmp.clone().cross(c).normalize(); const v=c.clone().cross(u).normalize();
  const w=new THREE.Vector3(0,0,1).sub(c.clone().multiplyScalar(ca)).multiplyScalar(1/Math.max(1e-6,sa));
  const t0=Math.atan2(w.dot(v),w.dot(u));
  return {c,ca,sa,u,v,t0};
}
function pointOnCircle(cf,t){ return cf.c.clone().multiplyScalar(cf.ca).add(cf.u.clone().multiplyScalar(Math.cos(t)*cf.sa)).add(cf.v.clone().multiplyScalar(Math.sin(t)*cf.sa)); }
function drawCircle(cf,arr){ for(let k=0;k<=RING_SEGS;k++){ const t=cf.t0+(k/RING_SEGS)*Math.PI*2; const p=pointOnCircle(cf,t); const i3=3*k; arr[i3]=p.x; arr[i3+1]=p.y; arr[i3+2]=p.z; } }
function renderDarSet(mode){
  const alpha = THREE.MathUtils.degToRad(30);
  const modeShift = (mode==='ARL') ? +Math.PI/2 : -Math.PI/2;
  const offsets=[ Math.PI/2, -Math.PI/2, 0, Math.PI ]; // Up,Down,Right,Left
  for(let i=0;i<4;i++){
    const cf = circleFrame(alpha, modeShift + offsets[i]);
    drawCircle(cf, darRings[i].buf);
    darRings[i].line.visible=true;
    darRings[i].line.geometry.attributes.position.needsUpdate=true;
  }
}

/* active path */
const activeGeo=new THREE.BufferGeometry();
activeGeo.setAttribute('position',new THREE.BufferAttribute(new Float32Array(3*N),3));
const activeMat=new THREE.LineBasicMaterial({color:0xffffff,opacity:0.95,transparent:true,depthTest:false});
const activeLine=new THREE.Line(activeGeo,activeMat); activeLine.visible=false; scene.add(activeLine);

/* car rig */
const carRoot=new THREE.Group(); scene.add(carRoot);
const carAim=new THREE.Group(); carRoot.add(carAim);        // full orientation node
const carSpin=new THREE.Group(); carAim.add(carSpin);       // extra roll node for DAR ON
const carOffset=new THREE.Group(); carSpin.add(carOffset);  // mesh offset
let carMesh=null;
let carScale=0.010, rodHeight=-0.200, carHeight=-0.200;
carRoot.position.set(0,rodHeight,0); carOffset.position.y=carHeight-rodHeight;
const fallback=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.24,0.8), new THREE.MeshStandardMaterial({color:0x8899aa,metalness:0.1,roughness:0.8,transparent:true,opacity:0.95}));
fallback.visible=true; carOffset.add(fallback);
function alignForwardToZ(obj, from='X'){
  const axes={X:new THREE.Vector3(1,0,0),'-X':new THREE.Vector3(-1,0,0),Y:new THREE.Vector3(0,1,0),'-Y':new THREE.Vector3(0,-1,0),Z:new THREE.Vector3(0,0,1),'-Z':new THREE.Vector3(0,0,-1)};
  const q=new THREE.Quaternion().setFromUnitVectors(axes[from]||axes.X,new THREE.Vector3(0,0,1));
  obj.quaternion.premultiply(q);
}
new GLTFLoader().load("models/car.glb",(gltf)=>{ carMesh=gltf.scene; alignForwardToZ(carMesh,'X'); carOffset.add(carMesh); fallback.visible=false; carSpin.scale.setScalar(carScale); });

/* stake + nose marker */
const stakeGeo=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(),new THREE.Vector3()]);
const stake=new THREE.Line(stakeGeo,new THREE.LineBasicMaterial({color:0x9aa6bd,transparent:true,opacity:0.9,depthTest:false}));
scene.add(stake);
const noseMarker=new THREE.Mesh(new THREE.SphereGeometry(0.02,16,12), new THREE.MeshBasicMaterial({color:0xffffff}));
scene.add(noseMarker);

/* UI bindings */
const morph=document.getElementById('morph'), morphTag=document.getElementById('morphTag');
const alphaSlider=document.getElementById('alpha'), alphaTag=document.getElementById('alphaTag');
const carSize=document.getElementById('carSize'), carSizeTag=document.getElementById('carSizeTag');
const carHeightEl=document.getElementById('carHeight'), carHeightTag=document.getElementById('carHeightTag');
const rodHeightEl=document.getElementById('rodHeight'), rodHeightTag=document.getElementById('rodHeightTag');
const btnARL=document.getElementById('arl'), btnARR=document.getElementById('arr');
let endConeDeg=+alphaSlider.value;
let darMode='OFF';
alphaSlider.addEventListener('input',()=>{ endConeDeg=+alphaSlider.value; alphaTag.textContent=endConeDeg+'°'; });
carSize.addEventListener('input',()=>{ carScale=+carSize.value; carSizeTag.textContent=carScale.toFixed(3); carSpin.scale.setScalar(carScale); });
function clampNumInput(el,min,max){ const v=parseFloat(el.value); if(Number.isNaN(v)) return; if(v<min) el.value=String(min); if(v>max) el.value=String(max); }
function applyHeights(){
  clampNumInput(rodHeightEl,-100,100); clampNumInput(carHeightEl,-100,100);
  rodHeight=parseFloat(rodHeightEl.value); carHeight=parseFloat(carHeightEl.value);
  rodHeightTag.textContent=rodHeight.toFixed(3); carHeightTag.textContent=carHeight.toFixed(3);
  carRoot.position.y=rodHeight; carOffset.position.y=carHeight-rodHeight;
}
rodHeightEl.addEventListener('change',applyHeights); rodHeightEl.addEventListener('input',applyHeights);
carHeightEl.addEventListener('change',applyHeights);  carHeightEl.addEventListener('input',applyHeights);
applyHeights();

/* toggles */
btnARL.addEventListener('click',()=>{
  const on = btnARL.getAttribute('aria-pressed')==='true';
  if(on){ darMode='OFF'; btnARL.setAttribute('aria-pressed','false'); }
  else { darMode='ARL'; btnARL.setAttribute('aria-pressed','true'); btnARR.setAttribute('aria-pressed','false'); }
});
btnARR.addEventListener('click',()=>{
  const on = btnARR.getAttribute('aria-pressed')==='true';
  if(on){ darMode='OFF'; btnARR.setAttribute('aria-pressed','false'); }
  else { darMode='ARR'; btnARR.setAttribute('aria-pressed','true'); btnARL.setAttribute('aria-pressed','false'); }
});
document.getElementById('reset').addEventListener('click',hardReset);

/* gamepad + stick UI */
let stickX=0, stickY=0;
function dz(v){ return Math.abs(v)<DEADZONE?0:v; }
function pollGamepad(){
  const pads=navigator.getGamepads?.()||[];
  for(const gp of pads){ if(!gp) continue; stickX=dz(gp.axes[0]||0); stickY=dz(-(gp.axes[1]||0)); return; }
}
const stickCanvas=document.getElementById('stick'), sctx=stickCanvas.getContext('2d'); const DPR=Math.min(devicePixelRatio||1,2);
stickCanvas.width=120*DPR; stickCanvas.height=120*DPR; stickCanvas.style.width='120px'; stickCanvas.style.height='120px';
const THETA_SHIFT=-Math.PI/4;
function drawStick(){
  const ctx=sctx,w=stickCanvas.width,h=stickCanvas.height,cx=w/2,cy=h/2; const R=Math.min(w,h)*0.45;
  ctx.clearRect(0,0,w,h);
  ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.strokeStyle='#2a3342'; ctx.lineWidth=2*DPR; ctx.stroke();
  ctx.beginPath(); ctx.arc(cx,cy,R*DEADZONE,0,Math.PI*2); ctx.strokeStyle='#3a4557'; ctx.setLineDash([4*DPR,4*DPR]); ctx.stroke(); ctx.setLineDash([]);
  const arcs=[
    {start:-Math.PI/2+THETA_SHIFT, end:0+THETA_SHIFT,           color:'#ff5c5c'},
    {start: Math.PI/2+THETA_SHIFT, end:Math.PI+THETA_SHIFT,     color:'#53d769'},
    {start: 0+THETA_SHIFT,         end:Math.PI/2+THETA_SHIFT,   color:'#4c8dff'},
    {start: Math.PI+THETA_SHIFT,   end:1.5*Math.PI+THETA_SHIFT, color:'#ffd166'}
  ];
  ctx.lineWidth=3*DPR;
  for(const a of arcs){ ctx.beginPath(); ctx.arc(cx,cy,R,a.start,a.end); ctx.strokeStyle=a.color; ctx.stroke(); }
  const kx=cx+stickX*R, ky=cy-stickY*R; ctx.beginPath(); ctx.arc(kx,ky,6*DPR,0,Math.PI*2); ctx.fillStyle='#e7ecf3'; ctx.fill(); ctx.strokeStyle='#1f2530'; ctx.lineWidth=1.5*DPR; ctx.stroke();
}

/* math utils */
function aimQuatFixedUp(fwd){
  const f=fwd.clone().normalize();
  let up=new THREE.Vector3(0,1,0);
  up = up.sub(f.clone().multiplyScalar(up.dot(f)));
  if(up.lengthSq()<1e-9){
    const helper=(Math.abs(f.z)<0.9)? new THREE.Vector3(0,0,1): new THREE.Vector3(1,0,0);
    up.copy(helper.sub(f.clone().multiplyScalar(helper.dot(f))));
  }
  up.normalize();
  const right=up.clone().cross(f).normalize();
  const realUp=f.clone().cross(right).normalize();
  const m=new THREE.Matrix4().makeBasis(right,realUp,f);
  return new THREE.Quaternion().setFromRotationMatrix(m);
}
function bigCircleFromTwoPoints(pA,pB){
  const n=pA.clone().cross(pB).normalize();
  if(!Number.isFinite(n.x) || n.lengthSq()<1e-8){
    const fallback=new THREE.Vector3(0,1,0).cross(pA).normalize();
    n.copy(fallback.lengthSq()<1e-8 ? new THREE.Vector3(1,0,0) : fallback);
  }
  const {u,v}=framePerp(n);
  const tA=Math.atan2(pA.dot(v),pA.dot(u));
  return {u,v,axis:n,tA};
}
function pointOnBigCircle(bc,t){ return bc.u.clone().multiplyScalar(Math.cos(t)).add(bc.v.clone().multiplyScalar(Math.sin(t))); }
function drawBigCircle(bc,arr){ for(let k=0;k<=RING_SEGS;k++){ const t=bc.tA+(k/RING_SEGS)*Math.PI*2; const p=pointOnBigCircle(bc,t); const i3=3*k; arr[i3]=p.x; arr[i3+1]=p.y; arr[i3+2]=p.z; } }
function circleFrame(alpha,phi){
  const ca=Math.cos(alpha), sa=Math.sin(alpha);
  const c=new THREE.Vector3(Math.sin(alpha)*Math.cos(phi),Math.sin(alpha)*Math.sin(phi),Math.cos(alpha)).normalize();
  const tmp=Math.abs(c.z)<0.9?new THREE.Vector3(0,0,1):new THREE.Vector3(0,1,0);
  const u=tmp.clone().cross(c).normalize(); const v=c.clone().cross(u).normalize();
  const w=new THREE.Vector3(0,0,1).sub(c.clone().multiplyScalar(ca)).multiplyScalar(1/Math.max(1e-6,sa));
  const t0=Math.atan2(w.dot(v),w.dot(u));
  return {c,ca,sa,u,v,t0};
}
function pointOnCircle(cf,t){ return cf.c.clone().multiplyScalar(cf.ca).add(cf.u.clone().multiplyScalar(Math.cos(t)*cf.sa)).add(cf.v.clone().multiplyScalar(Math.sin(t)*cf.sa)); }
function drawCircle(cf,arr){ for(let k=0;k<=RING_SEGS;k++){ const t=cf.t0+(k/RING_SEGS)*Math.PI*2; const p=pointOnCircle(cf,t); const i3=3*k; arr[i3]=p.x; arr[i3+1]=p.y; arr[i3+2]=p.z; } }
function framePerp(a){ const tmp=Math.abs(a.z)<0.9?new THREE.Vector3(0,0,1):new THREE.Vector3(0,1,0); const u=tmp.clone().cross(a).normalize(); const v=a.clone().cross(u).normalize(); return {u,v}; }
function angDiff(a,b){ let d=a-b; while(d> Math.PI) d-=2*Math.PI; while(d<-Math.PI) d+=2*Math.PI; return d; }
function getForward(q){ return new THREE.Vector3(0,0,1).applyQuaternion(q).normalize(); }

/* state */
let cfCurrent=null, bcCurrent=null;
let phase=0, lastPoint=null;
let phaseStart=0;
let lastTime=performance.now();
let prevDarMode='OFF', prevAlpha=0, prevPhi=0;

/* colors */
function activeColorByStick(x,y){
  const a=Math.atan2(y,x);
  if(a> Math.PI/4 && a<= 3*Math.PI/4) return darColors[0];
  if(a<=-Math.PI/4 && a> -3*Math.PI/4) return darColors[1];
  if(a>-Math.PI/4 && a<= Math.PI/4) return darColors[2];
  return darColors[3];
}
function zeroRoll(){ carSpin.quaternion.identity(); }

/* resets */
function hardReset(){
  camera.position.set(2.3,1.6,2.5); controls.target.set(0,0,0); controls.update();
  cfCurrent=null; bcCurrent=null; phase=0; phaseStart=0; lastPoint=null;
  morph.value="0"; morphTag.textContent="0.000";
  darMode='OFF'; btnARL.setAttribute('aria-pressed','false'); btnARR.setAttribute('aria-pressed','false');
  // start pose: nose +Z, roof +Y
  const startQ=aimQuatFixedUp(new THREE.Vector3(0,0,1));
  carAim.quaternion.copy(startQ); zeroRoll();
}
function resetToStartImmediate(rodAnchor){
  const start=new THREE.Vector3(0,0,1);
  noseMarker.position.copy(start);
  const q=aimQuatFixedUp(start.clone().sub(rodAnchor));
  carAim.quaternion.copy(q);
  zeroRoll();
  cfCurrent=null; bcCurrent=null; phase=0; phaseStart=0; lastPoint=null;
  const pa=stake.geometry.getAttribute('position');
  pa.setXYZ(0,rodAnchor.x,rodAnchor.y,rodAnchor.z);
  pa.setXYZ(1,start.x,start.y,start.z);
  pa.needsUpdate=true;
}

/* main update */
const angVelBase=2.2;
function update(dt){
  pollGamepad();
  const r=Math.hypot(stickX,stickY);
  const m=Math.min(1,Math.max(0,r));
  morph.value=String(m); morphTag.textContent=m.toFixed(3);

  for(const dr of darRings) dr.line.visible=false;
  for(const rL of rings) rL.line.visible=false;

  const darActive = (darMode==='ARL' || darMode==='ARR');
  const rodAnchor=new THREE.Vector3(0,rodHeight,0);

  function showGuides(){
    drawGreatCircles(); setGreatOpacity(darActive);
    for(const rL of rings) rL.line.visible=true;
    if(darActive){ renderDarSet(darMode); }
  }

  if(m<=DEADZONE+EPS){
    activeLine.visible=false;
    showGuides();
    resetToStartImmediate(rodAnchor);
    carRoot.position.copy(rodAnchor); carOffset.position.y=carHeight-rodHeight;
    drawStick();
    prevDarMode=darMode; prevAlpha=0; prevPhi=0;
    return;
  }

  /* DAR OFF — big circle, integrate orientation (free spin, no flips) */
  if(!darActive){
    const stickDir=new THREE.Vector3(stickX,stickY,0); if(stickDir.lengthSq()<1e-10) stickDir.set(1,0,0);
    stickDir.normalize();
    const front=new THREE.Vector3(0,0,1);
    const prevPoint=(bcCurrent ? pointOnBigCircle(bcCurrent,phase) : (lastPoint || front));
    const bc=bigCircleFromTwoPoints(front,stickDir);

    drawBigCircle(bc, activeGeo.attributes.position.array);
    activeGeo.attributes.position.needsUpdate=true;
    activeLine.visible=true;
    activeMat.color.setHex(0xffffff);

    const x=prevPoint.dot(bc.u), y=prevPoint.dot(bc.v);
    phase=Math.atan2(y,x);
    const speed=angVelBase * r;
    phase += speed*dt;
    bcCurrent=bc; cfCurrent=null;

    const noseTarget=pointOnBigCircle(bcCurrent,phase);
    lastPoint=noseTarget.clone(); noseMarker.position.copy(noseTarget);

    const pa=stake.geometry.getAttribute('position'); pa.setXYZ(0,rodAnchor.x,rodAnchor.y,rodAnchor.z); pa.setXYZ(1,noseTarget.x,noseTarget.y,noseTarget.z); pa.needsUpdate=true;

    // Angular velocity integration
    const nAxis = bcCurrent.axis.clone().normalize();          // circle axis
    const omega_path = nAxis.clone().multiplyScalar(speed);    // rad/s about axis
    const fwd = getForward(carAim.quaternion);                 // current nose
    const desired = noseTarget.clone().sub(rodAnchor).normalize();
    const corrAxis = fwd.clone().cross(desired);               // steer toward path
    const kAlign = 6.0;                                        // alignment gain
    const omega = omega_path.add(corrAxis.multiplyScalar(kAlign)); // total ω

    const mag = omega.length();
    if(mag>1e-6){
      const dq = new THREE.Quaternion().setFromAxisAngle(omega.normalize(), mag*dt);
      carAim.quaternion.premultiply(dq);
    }
    carSpin.quaternion.identity(); // no extra roll node DAR OFF

    carRoot.position.copy(rodAnchor); carOffset.position.y=carHeight-rodHeight;
    drawStick();
    prevDarMode='OFF'; prevAlpha=0; prevPhi=0;
    return;
  }

  /* DAR ON — active ring; roll exactly matches phase progress */
  const aMin=THREE.MathUtils.degToRad(0.001), aMax=THREE.MathUtils.degToRad(endConeDeg);
  const alpha=THREE.MathUtils.lerp(aMin,aMax,m);
  let phi=Math.atan2(stickY,stickX);
  let travelDir, spinDir;
  if(darMode==='ARR'){ phi-=Math.PI/2; travelDir=+1; spinDir=+1; }
  else               { phi+=Math.PI/2; travelDir=-1; spinDir=+1; }

  const prevPointDAR=(cfCurrent?pointOnCircle(cfCurrent,phase):(lastPoint||new THREE.Vector3(0,0,1)));
  const cf=circleFrame(alpha,phi);
  drawCircle(cf,activeGeo.attributes.position.array);
  activeGeo.attributes.position.needsUpdate=true;
  activeLine.visible=true;
  activeMat.color.setHex(activeColorByStick(stickX,stickY));

  const center=cf.c.clone().multiplyScalar(cf.ca);
  const qv=prevPointDAR.clone().normalize().sub(center);
  const x2=qv.dot(cf.u), y2=qv.dot(cf.v);
  const phaseProj=Math.atan2(y2,x2);

  const changed = (!cfCurrent) || (darMode!==prevDarMode) ||
                  (Math.abs(alpha-prevAlpha)>1e-5) ||
                  (Math.abs(angDiff(phi,prevPhi))>1e-5);
  if(changed){ phase=phaseProj; phaseStart=phaseProj; }

  const speedDAR=angVelBase*(0.3+0.7*(alpha/aMax));
  phase += travelDir*speedDAR*dt;

  cfCurrent=cf; bcCurrent=null;
  prevDarMode=darMode; prevAlpha=alpha; prevPhi=phi;

  const noseTarget=pointOnCircle(cfCurrent,phase);
  lastPoint=noseTarget.clone(); noseMarker.position.copy(noseTarget);

  const pa=stake.geometry.getAttribute('position'); pa.setXYZ(0,rodAnchor.x,rodAnchor.y,rodAnchor.z); pa.setXYZ(1,noseTarget.x,noseTarget.y,noseTarget.z); pa.needsUpdate=true;

  // Aim by parallel transport for smoothness, then add explicit roll node 1:1
  const stakeDir=noseTarget.clone().sub(rodAnchor).normalize();

  // Build PT without world-up constraint
  const fwdNow = getForward(carAim.quaternion);
  const qDelta = new THREE.Quaternion().setFromUnitVectors(fwdNow, stakeDir);
  const upGuess = new THREE.Vector3(0,1,0).applyQuaternion(carAim.quaternion);
  let upT = upGuess.clone().applyQuaternion(qDelta);
  upT.sub(stakeDir.clone().multiplyScalar(upT.dot(stakeDir))).normalize();
  const right=upT.clone().cross(stakeDir).normalize();
  const realUp=stakeDir.clone().cross(right).normalize();
  const m=new THREE.Matrix4().makeBasis(right,realUp,stakeDir);
  const qPT=new THREE.Quaternion().setFromRotationMatrix(m);

  const lerp=1-Math.exp(-dt*12);
  carAim.quaternion.slerp(qPT, lerp);

  const rollAngle = spinDir * (phase - phaseStart);
  carSpin.quaternion.setFromAxisAngle(new THREE.Vector3(0,0,1), rollAngle);

  carRoot.position.copy(rodAnchor); carOffset.position.y=carHeight-rodHeight;
  drawStick();
}

/* animate */
let lastTime=performance.now();
function tick(){ const now=performance.now(); const dt=Math.min(0.05,(now-lastTime)/1000); lastTime=now; update(dt); controls.update(); renderer.render(scene,camera); requestAnimationFrame(tick); }

/* boot */
drawGreatCircles(); setGreatOpacity(false); tick();

/* resize */
addEventListener('resize',()=>{
  const h=document.querySelector('header').offsetHeight;
  renderer.setSize(innerWidth,innerHeight-h);
  camera.aspect=renderer.domElement.width/renderer.domElement.height;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
